<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="GoKu ">
<meta name="description" content="文件属性 更改文件属性   chgrp：更改文件属组
#语法chgrp [-R] 属组名 文件名参数选项
 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。  root@Kali:~# touch test.txtroot@Kali:~# ls -l test.txt -rw-r--r-- 1 root root 0 Jan 21 09:06 test.txtroot@Kali:~# chgrp test test.txtroot@Kali:~# ls -l test.txt -rw-r--r-- 1 root test 0 Jan 21 09:06 test.txt  chown：更改文件属主，也可以同时更改文件属组
#语法chown [-R] 属主名 文件名chown [-R] 属主名:属主名 文件名#实例：将/root目录（~）下test.txt的拥有者改为binroot@Kali:~# chown bin test.txtroot@Kali:~# ls -l test.txt -rw-r--r-- 1 bin test 0 Jan 21 09:06 test." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="#252627" />
<link rel="canonical" href="https://Sun-GoKu.github.io/blog/2020/03/linux%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/" />


    <title>
        
            Linux基本知识点 :: Welcome to my Blog  — Hello Friend NG Theme
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="https://Sun-GoKu.github.io/main.min.7bfbbe12786fa0ded4b4c0d792cbb36a5bd0bdb0b856dde57aa7b1f6fe0f2b87.css">




    <link rel="apple-touch-icon" sizes="180x180" href="https://Sun-GoKu.github.io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://Sun-GoKu.github.io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://Sun-GoKu.github.io/favicon-16x16.png">
    <link rel="manifest" href="https://Sun-GoKu.github.io/site.webmanifest">
    <link rel="mask-icon" href="https://Sun-GoKu.github.io/safari-pinned-tab.svg" color="#252627">
    <link rel="shortcut icon" href="https://Sun-GoKu.github.io/favicon.ico">
    <meta name="msapplication-TileColor" content="#252627">
    <meta name="theme-color" content="#252627">

<meta itemprop="name" content="Linux基本知识点">
<meta itemprop="description" content="文件属性 更改文件属性   chgrp：更改文件属组
#语法chgrp [-R] 属组名 文件名参数选项
 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。  root@Kali:~# touch test.txtroot@Kali:~# ls -l test.txt -rw-r--r-- 1 root root 0 Jan 21 09:06 test.txtroot@Kali:~# chgrp test test.txtroot@Kali:~# ls -l test.txt -rw-r--r-- 1 root test 0 Jan 21 09:06 test.txt  chown：更改文件属主，也可以同时更改文件属组
#语法chown [-R] 属主名 文件名chown [-R] 属主名:属主名 文件名#实例：将/root目录（~）下test.txt的拥有者改为binroot@Kali:~# chown bin test.txtroot@Kali:~# ls -l test.txt -rw-r--r-- 1 bin test 0 Jan 21 09:06 test.">
<meta itemprop="datePublished" content="2020-03-08T22:29:37&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-08T22:29:37&#43;08:00" />
<meta itemprop="wordCount" content="3235">
<meta itemprop="image" content="https://Sun-GoKu.github.io/"/>



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://Sun-GoKu.github.io/"/>

<meta name="twitter:title" content="Linux基本知识点"/>
<meta name="twitter:description" content="文件属性 更改文件属性   chgrp：更改文件属组
#语法chgrp [-R] 属组名 文件名参数选项
 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。  root@Kali:~# touch test.txtroot@Kali:~# ls -l test.txt -rw-r--r-- 1 root root 0 Jan 21 09:06 test.txtroot@Kali:~# chgrp test test.txtroot@Kali:~# ls -l test.txt -rw-r--r-- 1 root test 0 Jan 21 09:06 test.txt  chown：更改文件属主，也可以同时更改文件属组
#语法chown [-R] 属主名 文件名chown [-R] 属主名:属主名 文件名#实例：将/root目录（~）下test.txt的拥有者改为binroot@Kali:~# chown bin test.txtroot@Kali:~# ls -l test.txt -rw-r--r-- 1 bin test 0 Jan 21 09:06 test."/>





    <meta property="article:published_time" content="2020-03-08 22:29:37 &#43;0800 CST" />









<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    </head>

    <body class="dark-theme">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="https://Sun-GoKu.github.io/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">[GoKu]# ls /home</span>
            <span class="logo__cursor" style=""></span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://Sun-GoKu.github.io/blog/">Blog</a></li><li><a href="https://Sun-GoKu.github.io/moment/">Moment</a></li><li><a href="https://Sun-GoKu.github.io/about/">About</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            

            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title" ><a href="https://Sun-GoKu.github.io/blog/2020/03/linux%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/">Linux基本知识点</a></h2>
            
            <div id="wc" style="font-size:50%;text-align: left;">3300 Words|Read in about 16 Min|Views:<span id="busuanzi_value_page_pv"></span></div>

            

            <div class="post-content">
                <h3 id="heading">文件属性</h3>
<h4 id="heading-1">更改文件属性</h4>
<ol>
<li>
<p><code>chgrp</code>：更改文件属组</p>
<pre><code>#语法
chgrp [-R] 属组名 文件名
</code></pre><p>参数选项</p>
<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
<pre><code class="language-linux" data-lang="linux">root@Kali:~# touch test.txt
root@Kali:~# ls -l test.txt 
-rw-r--r-- 1 root root 0 Jan 21 09:06 test.txt
root@Kali:~# chgrp test test.txt
root@Kali:~# ls -l test.txt 
-rw-r--r-- 1 root test 0 Jan 21 09:06 test.txt
</code></pre></li>
<li>
<p><code>chown</code>：更改文件属主，也可以同时更改文件属组</p>
<pre><code>#语法
chown [-R] 属主名 文件名
chown [-R] 属主名:属主名 文件名
</code></pre><pre><code>#实例：将/root目录（~）下test.txt的拥有者改为bin
   
root@Kali:~# chown bin test.txt
root@Kali:~# ls -l test.txt 
-rw-r--r-- 1 bin test 0 Jan 21 09:06 test.txt
</code></pre><pre><code>#实例：将test.txt的拥有者与属组改回root
   
root@Kali:~# chown root:root test.txt
root@Kali:~# ls -l test.txt 
-rw-r--r-- 1 root root 0 Jan 21 09:06 test.txt
</code></pre></li>
<li>
<p><code>chmod</code>：更改文件9个属性</p>
<p>Linux文件的基本权限有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p>
<p>权限分数表如下：</p>
<ul>
<li>r：4</li>
<li>w：2</li>
<li>x：1</li>
</ul>
<p>每种身份各自的三个权限分数是需要累加的，例如当权限为：<code>[-rwxrwx---]</code>分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others = &mdash; = 0+0+0 = 0</li>
</ul>
<p>所以等下我们设定权限的变更时，该文件的权限数字就是770</p>
<h6 id="heading-2">数字类型改变文件权限</h6>
<p>语法如下：</p>
<pre><code>chmod [-R] xyz 文件或目录
</code></pre><p>选项与参数：</p>
<ul>
<li>xyz：就是刚刚提高的数字类型的权限属性，为rwx属性数值的相加</li>
<li>-R：进行递归（recursive）的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<pre><code>#实例：将test.txt文件的权限属性更改为777
   
root@Kali:~# ls -al test.txt
-rw-r--r-- 1 root root 0 Jan 21 09:06 test.txt
root@Kali:~# chmod 777 test.txt
root@Kali:~# ls -al test.txt
-rwxrwxrwx 1 root root 0 Jan 21 09:06 test.txt
root@Kali:~# 
</code></pre><h6 id="heading-3">符号类型改变文件权限</h6>
<p>上面说到，九个权限分别是user/group/others三种身份的。所以可以用u、g、o代表三种身份的权限。此外a则代表all，即全部的身份。则符号类型改变文件权限的语法如下：</p>
<pre><code>chmod u=[rwx],g=[rwx],o=[rwx] 文件名
或
chmod u+[rwx],g+[rwx],o+[rwx] 文件名
或
chmod u-[rwx],g-[rwx],o-[rwx] 文件名
或
chmod a-[rwx] 文件名
</code></pre><pre><code>#实例
root@Kali:~# ls -al test.txt
-rwxrw---x 1 root root 0 Jan 21 09:06 test.txt
   
root@Kali:~# chmod o+r test.txt
root@Kali:~# ls -al test.txt
-rwxrw-r-x 1 root root 0 Jan 21 09:06 test.txt
   
root@Kali:~# chmod g+x,o+w test.txt
root@Kali:~# ls -al test.txt
-rwxrwxrwx 1 root root 0 Jan 21 09:06 test.txt
   
root@Kali:~# chmod u-x,g-wx,o-wx test.txt
root@Kali:~# ls -al test.txt
-rw-r--r-- 1 root root 0 Jan 21 09:06 test.txt
root@Kali:~# 
</code></pre></li>
</ol>
<h3 id="heading-4">文件与目录管理</h3>
<ul>
<li>
<p>绝对路径：</p>
<p>路径的写法，有根目录<code>/</code>写起，例如：<code>/usr/share/doc</code></p>
</li>
<li>
<p>相对路径：</p>
<p>路径的写法，不是由<code>/</code>写起，例如由 <code>/usr/share/doc</code> 要到 <code>/usr/share/man</code>底下时，可以写成：<code>cd ../man</code>这就是相对路径的写法。</p>
</li>
</ul>
<h4 id="heading-5">处理目录的常用命令</h4>
<ul>
<li>ls：列出目录</li>
<li>cd：切换目录</li>
<li>pwd：显示目前的目录</li>
<li>mkdir：创建一个新的目录</li>
<li>rmdir：删除一个空的目录</li>
<li>cp：复制文件或目录</li>
<li>rm：移除文件或目录</li>
<li>mv：移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p><strong>注释</strong>：可以使用man [命令]来查看各个命令的使用文档，如：man cp</p>
<h5 id="ls">ls（列出目录）</h5>
<p>语法：</p>
<pre><code>[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称
[root@www ~]# ls [--color={never,auto,always}] 目录名称
[root@www ~]# ls [--full-time] 目录名称
</code></pre><p>选项与参数：</p>
<ul>
<li>-a：全部的文件，连同隐藏文件（开头为<code>.</code>的文件）一起列出来</li>
<li>-d：仅列出目录本身，而不是列出列出目录内的文件数据</li>
<li>-l：长数据串列出，包含文件的属性与权限等等数据</li>
</ul>
<p>将家目录下的所有文件列出来（含属性与隐藏档）</p>
<pre><code>[root@www ~]# ls -al ~
</code></pre><pre><code>root@ubantu:/home# ls -l
total 120080
-rw-r--r--  1 root    root      10240 Mar  8 15:12 a1.tar
-rw-r--r--  1 root    root          0 Mar  8 15:02 a1.txt
-rw-r--r--  1 root    root          0 Mar  8 15:02 a2.txt
-rw-r--r--  1 root    root        121 Mar  8 15:03 a.tar.gz
-rw-r--r--  1 root    root         57 Mar  8 11:27 hello.txt
drwxr-xr-x 17 leven   leven      4096 Mar  8 10:51 leven

#解析：以上每一行分为18个位置来解析，从0开始
0：表示文件类型，“-”为普通文件；“d”为目录；“l”为软链接；“c”为字符设备[鼠标、键盘]；“b”为块文件、硬盘
1-9：分别表示所有者、所在组、其他组的对该文件或目录的权限
10：如果是文件，则表示硬链接的数量，如果是目录则表示该目录下的子目录个数
11、12：所有者、所在组
13：文件大小，如果是目录该数字为4096
14、15、16：最后修改时间
17：文件名或目录名
</code></pre><h5 id="cd">cd（切换目录）</h5>
<p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<pre><code>cd [相对路径或绝对路径]
</code></pre><pre><code>#使用 mkdir 命令创建 BLOG 目录
[root@www ~]# mkdir BLOG

#使用绝对路径切换到 BLOG 目录
[root@www ~]# cd /root/BLOG/

#使用相对路径切换到 BLOG 目录
[root@www ~]# cd ./BLOG/

# 表示回到自己的家目录，亦即是 /root 这个目录
[root@www runoob]# cd ~

# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；
[root@www ~]# cd ..
</code></pre><h5 id="pwd">pwd（显示目前所在的目录）</h5>
<p>pwd 是<code>print Working Directory</code>的缩写，也就是显示目前所在目录的命令。</p>
<pre><code>[root@www ~]# pwd [-P]
</code></pre><p>选项与参数：</p>
<ul>
<li><code>-p</code>：显示出确实的路径，而非使用链接（link）路径</li>
</ul>
<p>实例：单纯显示出目前的工作目录：</p>
<pre><code>[root@www ~]# pwd
/root 
</code></pre><p>实例：显示出实际的工作目录，而非链接档本身的目录名而已</p>
<pre><code>[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个连结档
[root@www mail]# pwd
/var/mail         &lt;==列出目前的工作目录
[root@www mail]# pwd -P
/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～
[root@www mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail
# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail 
# 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！
</code></pre><h5 id="mkdir">mkdir（创建新目录）</h5>
<p>语法：</p>
<pre><code>mkdir [-mp] 目录名称
</code></pre><p>选项与参数：</p>
<ul>
<li>-m：配置文件的权限，直接配置，不需要看默认权限 (umask) 的脸色</li>
<li>-p：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
<p>实例：请到/tmp底下尝试创建数个新目录看看：</p>
<pre><code>[root@www ~]# cd /tmp
[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录
[root@www tmp]# mkdir test1/test2/test3/test4
mkdir: cannot create directory `test1/test2/test3/test4': 
No such file or directory       &lt;== 没办法直接创建此目录啊！
[root@www tmp]# mkdir -p test1/test2/test3/test4
</code></pre><p>加了这个-p选项，可以自行帮你创建多层目录</p>
<p>实例：创建权限为 <strong>rwx&ndash;x&ndash;x</strong> 的目录</p>
<pre><code>[root@www tmp]# mkdir -m 711 test2
[root@www tmp]# ls -l
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
</code></pre><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p>
<p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx&ndash;x&ndash;x 的权限。</p>
<h5 id="rmdir">rmdir（删除空的目录）</h5>
<p>语法：</p>
<pre><code>rmdir [-p] 目录名称
</code></pre><p>选项与参数：</p>
<ul>
<li>-p：连同上一级『空的』目录也一起删除</li>
</ul>
<p>删除test目录</p>
<pre><code>[root@www tmp]# rmdir test/
</code></pre><p>将mkdir实例中创建的目录（/tmp底下）删除掉</p>
<pre><code>[root@www tmp]# ls -l   &lt;==看看有多少目录存在？
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题
[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！
rmdir: `test1': Directory not empty
[root@www tmp]# rmdir -p test1/test2/test3/test4
[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
</code></pre><p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p>
<p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p>
<h5 id="cp">cp（复制文件或目录）</h5>
<p>语法：</p>
<pre><code>[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)
[root@www ~]# cp [options] source1 source2 source3 .... directory
</code></pre><p>选项与参数：</p>
<ul>
<li>**-a：**相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li>**-d：**若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li>
<li>**-f：**为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li>**-i：**若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li>**-l：**进行硬式连结(hard link)的连结档创建，而非复制文件本身；</li>
<li>**-p：**连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li>**-r：**递归持续复制，用於目录的复制行为；(常用)</li>
<li>**-s：**复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li>
<li>**-u：**若 destination 比 source 旧才升级 destination ！</li>
</ul>
<p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p>
<pre><code>[root@www ~]# cp ~/.bashrc /tmp/bashrc
[root@www ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite `/tmp/bashrc'? n  &lt;==n不覆盖，y为覆盖
</code></pre><h5 id="rm">rm（移除文件或目录）</h5>
<p>语法：</p>
<pre><code>rm [-fir] 文件或目录
</code></pre><p>选项与参数：</p>
<ul>
<li><strong>-f</strong> ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li><strong>-i</strong> ：互动模式，在删除前会询问使用者是否动作</li>
<li><strong>-r</strong> ：递归删除啊！最常用在目录的删除了</li>
</ul>
<p>将刚刚在 cp 的实例中创建的 bashrc 删除掉</p>
<pre><code>[root@www tmp]# rm -i bashrc
rm: remove regular file `bashrc'? y
</code></pre><p>如果加上 -i 的选项就会主动询问，避免你删除到错误的档名！</p>
<h5 id="mv">mv（移动文件与目录，或修改名称）</h5>
<p>语法：</p>
<pre><code>[root@www ~]# mv [-fiu] source destination
[root@www ~]# mv [options] source1 source2 source3 .... directory
</code></pre><p>选项与参数：</p>
<ul>
<li>**-f **：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li><strong>-i</strong> ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li><strong>-u</strong> ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p>复制一文件，创建一目录，将文件移动到目录中</p>
<pre><code>[root@www ~]# cd /tmp
[root@www tmp]# cp ~/.bashrc bashrc
[root@www tmp]# mkdir mvtest
[root@www tmp]# mv bashrc mvtest
</code></pre><p>将某个文件移动到某个目录去，就是这样做！</p>
<p>将刚刚的目录名称更名为 mvtest2</p>
<pre><code>[root@www tmp]# mv mvtest mvtest2
</code></pre><h4 id="linux">Linux文件内容查看</h4>
<p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li><strong>cat</strong> 由第一行开始显示文件内容</li>
<li><strong>tac</strong> 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！</li>
<li><strong>nl</strong>  显示的时候，顺道输出行号！</li>
<li><strong>more</strong> 一页一页的显示文件内容</li>
<li><strong>less</strong> 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li><strong>head</strong>只看头几行</li>
<li><strong>tail</strong> 只看尾巴几行</li>
</ul>
<h5 id="cat">cat</h5>
<p>由第一行开始显示文件内容</p>
<p>语法：</p>
<pre><code>cat [-AbEnTv]
</code></pre><p>选项与参数：</p>
<ul>
<li><strong>-A</strong> ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li><strong>-b</strong> ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li><strong>-E</strong> ：将结尾的断行字节 $ 显示出来；</li>
<li><strong>-n</strong> ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li><strong>-T</strong> ：将 [tab] 按键以 ^I 显示出来；</li>
<li><strong>-v</strong>：列出一些看不出来的特殊字符</li>
</ul>
<p>检看/etc/issue这个文件的内容：</p>
<pre><code>[root@www ~]# cat /etc/issue
CentOS release 6.4 (Final)
Kernel \r on an \m
</code></pre><h5 id="tac">tac</h5>
<p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<pre><code>[root@www ~]# tac /etc/issue

Kernel \r on an \m
CentOS release 6.4 (Final)
</code></pre><h5 id="nl">nl</h5>
<p>显示行号</p>
<p>语法：</p>
<pre><code>nl [-bnw] 文件
</code></pre><p>选项与参数：</p>
<ul>
<li>
<p>-b ：指定行号指定的方式，主要有两种：
-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；
-b t ：如果有空行，空的那一行不要列出行号(默认值)；</p>
</li>
<li>
<p>-n ：列出行号表示的方法，主要有三种：
-n ln ：行号在荧幕的最左方显示；
-n rn ：行号在自己栏位的最右方显示，且不加 0 ；
-n rz ：行号在自己栏位的最右方显示，且加 0 ；</p>
</li>
<li>
<p>-w ：行号栏位的占用的位数</p>
</li>
</ul>
<p>实例一：用nl列出/etc/issue的内容</p>
<pre><code>[root@www ~]# nl /etc/issue
     1  CentOS release 6.4 (Final)
     2  Kernel \r on an \m
</code></pre><h5 id="more">more</h5>
<p>一页一页翻动</p>
<pre><code>[root@www ~]# more /etc/man_db.config 
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
--More--(28%)  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令
</code></pre><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter     ：代表向下翻『一行』；</li>
<li>/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f      ：立刻显示出档名以及目前显示的行数；</li>
<li>q       ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用</li>
</ul>
<h5 id="less">less</h5>
<p>一页一页翻动，以下实例输出/etc/man.config文件的内容：</p>
<pre><code>[root@www ~]# less /etc/man.config
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
:   &lt;== 这里可以等待你输入命令
</code></pre><p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>/字串   ：向下搜寻『字串』的功能；</li>
<li>?字串   ：向上搜寻『字串』的功能；</li>
<li>n     ：重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>q     ：离开 less 这个程序；</li>
</ul>
<h5 id="head">head</h5>
<p>取出文件前面几行</p>
<p>语法：</p>
<pre><code>head [-n number] 文件 
</code></pre><p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<pre><code>[root@www ~]# head /etc/man.config
</code></pre><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<pre><code>[root@www ~]# head -n 20 /etc/man.config
</code></pre><h5 id="tail">tail</h5>
<p>取出文件后面几行</p>
<p>语法：</p>
<pre><code>tail [-n number] 文件
</code></pre><p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
<li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li>
</ul>
<pre><code>[root@www ~]# tail /etc/man.config
# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：
[root@www ~]# tail -n 20 /etc/man.config
</code></pre><h3 id="linux-1">Linux用户和用户组管理</h3>
<h4 id="linux-2">一、Linux系统用户账号的管理</h4>
<p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。</p>
<h5 id="1">1、添加（创建）用户</h5>
<pre><code>useradd 选项 用户名
</code></pre><p>参数说明：</p>
<ul>
<li>
<p>选项:</p>
<ul>
<li>-c comment 指定一段注释性描述。</li>
<li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li>
<li>-g 用户组 指定用户所属的用户组。</li>
<li>-G 用户组，用户组 指定用户所属的附加组。</li>
<li>-s Shell文件 指定用户的登录Shell。</li>
<li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
</ul>
</li>
<li>
<p>用户名:</p>
<p>指定新账号的登录名</p>
</li>
</ul>
<p>实例1</p>
<pre><code>root@Kali:~# useradd -d /home/sam -m sam
</code></pre><p>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）</p>
<p>实例2</p>
<pre><code>root@Kali:~# useradd -s /bin/sh -g group -G adm,root gem
</code></pre><p>此命令新建了一个用户gem，该用户的登录Shell是 <code>/bin/sh</code>，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。</p>
<p>这里可能新建组：<code>#groupadd group及groupadd adm</code></p>
<p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p>
<p>Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。</p>
<h5 id="2">2、删除账号（用户）</h5>
<p>如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<pre><code>userdel 选项 用户名
</code></pre><p>常用的选项是<strong><code>-r</code></strong>，它的作用是把用户的主目录一起删除。</p>
<p>例如：</p>
<pre><code>root@Kali:~# userdel -r sam
</code></pre><p>此命令删除用户sam在系统文件中（主要是/etc/passwd，/etc/shadow，/etc/group等）的记录，同时删除用户的主目录。</p>
<h5 id="3">3、修改账号</h5>
<p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令，其格式如下：</p>
<pre><code>usermod 选项 用户名
</code></pre><p>常用的选项包括<code>-c, -d, -m, -g, -G, -s, -u以及-o等</code>，这些选项的意义与<code>useradd</code>命令中的选项一样，可以为用户指定新的资源值。</p>
<p>另外，有些系统可以使用选项：-l 新用户名，这个选项指定一个新的账号，即将原来的用户名改为新的用户名。</p>
<p>例如：</p>
<pre><code>root@Kali:~# usermod -s /bin/ksh -d /home/z -g developer sam
</code></pre><p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p>
<h5 id="4">4、用户口令的管理</h5>
<p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是<code>passwd</code>。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：</p>
<pre><code>passwd 选项 用户名
</code></pre><p>可使用的选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>例如，假设当前用户是sam，则下面的命令修改用户自己的口令：</p>
<pre><code>root@Kali:~# passwd
Old password:****** 
New password:******* 
Re-enter new password:*******
</code></pre><p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<pre><code>root@Kali:~# passwd tom
New password: 
Retype new password: 
passwd: password updated successfully
</code></pre><p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p>
<p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p>
<p>为用户指定空口令时，执行下列形式的命令：</p>
<pre><code>root@Kali:~# passwd -d sam
</code></pre><p>此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<pre><code>root@Kali:~# passwd -l sam
</code></pre><h5 id="5">5、查询用户</h5>
<pre><code>id 用户名
</code></pre><pre><code>leven@ubantu:~$ id leven
uid=1000(leven) gid=1000(leven) groups=1000(leven),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)
</code></pre><h5 id="6">6、切换用户</h5>
<pre><code>su - 用户名
</code></pre><pre><code>root@ubantu:/home/leven# su - leven
leven@ubantu:~$ 

#退回原来的用户
leven@ubantu:~$ exit
logout
root@ubantu:/home/leven# 

#特别的，在ubantu中，默认是不允许用su来切换root用户的，若要使用则输以下指令
leven@ubantu:/home$ sudo passwd
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
leven@ubantu:/home$ su root
Password: 
root@ubantu:/home# 
#从上面可以看出，执行sudo passwd并设置密码后即可用su来切换root用户
</code></pre><h4 id="linux-3">二、Linux系统用户组的管理</h4>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<h5 id="1groupadd">1、groupadd</h5>
<pre><code>group 选项 用户组
</code></pre><p>可以使用的选项有：</p>
<ul>
<li>-g GID 指定新用户组的组标识号（GID）。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<p>实例1：</p>
<pre><code>root@Kali:~# groupadd group1
</code></pre><p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p>
<p>实例2：</p>
<pre><code>root@Kali:~# groupadd -g 404 group2
</code></pre><p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是404。</p>
<h5 id="2groupdel">2、groupdel</h5>
<pre><code>groupdel 用户组
</code></pre><p>例如：</p>
<pre><code>root@Kali:~# groupdel group1
</code></pre><p>此命令从系统中删除组group1。</p>
<h5 id="3groupmod">3、groupmod</h5>
<p>修改用户组的属性</p>
<pre><code>groupmod 选项 用户组
</code></pre><p>常用的选项有：</p>
<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n新用户组 将用户组的名字改为新名字</li>
</ul>
<p>实例1：</p>
<pre><code>root@Kali:~# groupmod -g 401 group2
</code></pre><p>此命令将组group2的组标识号修改为102。</p>
<p>实例2：</p>
<pre><code>root@Kali:~# groupmod -g 403 -n group3 group2
</code></pre><p>此命令将组group2的标识号改为10000，组名修改为group3。</p>
<h5 id="4-1">4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</h5>
<p>用户可以登录后，使用命令newgrp切换其他用户组，这个命令的参数就是目的用户组。例如：</p>
<pre><code>root@Kali:~# newgrp root
</code></pre><p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p>
<h4 id="heading-6">三、与用户账号有关的系统文件</h4>
<p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<h5 id="1etcpasswd">1、/etc/passwd文件是用户管理工作涉及的最重要的一个文件</h5>
<p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<pre><code>root@Kali:~# cat /etc/passwd
root❌0:0:root:/root:/bin/bash
daemon❌1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin❌2:2:bin:/bin:/usr/sbin/nologin
sys❌3:3:sys:/dev:/usr/sbin/nologin
sync❌4:65534:sync:/bin:/bin/sync
games❌5:60:games:/usr/games:/usr/sbin/nologin
man❌6:12:man:/var/cache/man:/usr/sbin/nologin
lp❌7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail❌8:8:mail:/var/mail:/usr/sbin/nologin
news❌9:9:news:/var/spool/news:/usr/sbin/nologin
uucp❌10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy❌13:13:proxy:/bin:/usr/sbin/nologin
www-data❌33:33:www-data:/var/www:/usr/sbin/nologin
backup❌34:34:backup:/var/backups:/usr/sbin/nologin
list❌38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc❌39:39:ircd:/var/run/ircd:/usr/sbin/nologin
gnats❌41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
nobody❌65534:65534:nobody:/nonexistent:/usr/sbin/nologin
_apt❌100:65534::/nonexistent:/usr/sbin/nologin
systemd-timesync❌101:102:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin
systemd-network❌102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin
systemd-resolve❌103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin
mysql❌104:110:MySQL Server,,,:/nonexistent:/bin/false
ntp❌105:111::/nonexistent:/usr/sbin/nologin
messagebus❌106:112::/nonexistent:/usr/sbin/nologin
uuidd❌107:113::/run/uuidd:/usr/sbin/nologin
redsocks❌108:114::/var/run/redsocks:/usr/sbin/nologin
rwhod❌109:65534::/var/spool/rwho:/usr/sbin/nologin
iodine❌110:65534::/var/run/iodine:/usr/sbin/nologin
tcpdump❌111:117::/nonexistent:/usr/sbin/nologin
miredo❌112:65534::/var/run/miredo:/usr/sbin/nologin
dnsmasq❌113:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin
usbmux❌114:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
rtkit❌115:121:RealtimeKit,,,:/proc:/usr/sbin/nologin
_rpc❌116:65534::/run/rpcbind:/usr/sbin/nologin
Debian-snmp❌117:123::/var/lib/snmp:/bin/false
statd❌118:65534::/var/lib/nfs:/usr/sbin/nologin
postgres❌119:124:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash
stunnel4❌120:126::/var/run/stunnel4:/usr/sbin/nologin
sshd❌121:65534::/run/sshd:/usr/sbin/nologin
sslh❌122:128::/nonexistent:/usr/sbin/nologin
pulse❌123:130:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin
avahi❌124:132:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin
saned❌125:133::/var/lib/saned:/usr/sbin/nologin
inetsim❌126:135::/var/lib/inetsim:/usr/sbin/nologin
colord❌127:136:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
geoclue❌128:137::/var/lib/geoclue:/usr/sbin/nologin
lightdm❌129:138:Light Display Manager:/var/lib/lightdm:/bin/false
king-phisher❌130:139::/var/lib/king-phisher:/usr/sbin/nologin
systemd-coredump❌999:999:systemd Core Dumper:/:/usr/sbin/nologin
gem❌1001:1002::/home/gem:/bin/sh
sam❌1002:1004::/home/z:/bin/ksh
tom❌1003:1005::/home/tom:/bin/sh
</code></pre><p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<pre><code>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
</code></pre><h5 id="1-1">1）&ldquo;用户名&quot;是代表用户账号的字符串</h5>
<p>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<h5 id="2-1">2）“口令”一些系统中，存放这加密后的用户口令</h5>
<p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<h5 id="3-1">3）“用户标识号”是一个整数，系统内部用它来标识用户</h5>
<p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<h5 id="4-2">4）“组标识号”字段记录的是用户所属的用户组。</h5>
<p>它对应着/etc/group文件中的一条记录</p>
<h5 id="5-1">5）“注释性描述“字段记录着用户的一些个人情况</h5>
<p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出</p>
<h5 id="6-1">6）”主目录“，也就是用户的起始工作目录</h5>
<p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<h5 id="7shell">7）用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</h5>
<p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<h5 id="8pseudo-users">8）系统中有一类用户称为伪用户（pseudo users）</h5>
<p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<pre><code>伪 用 户 含 义 
bin 拥有可执行的用户命令文件 
sys 拥有系统文件 
adm 拥有帐户文件 
uucp UUCP使用 
lp lp或lpd子系统使用 
nobody NFS使用
</code></pre><h4 id="heading-7">拥有账户文件</h4>
<h6 id="1auditcronmailusenet">1、除了上面列出的伪用户，还有许多标准的伪用户，例如：audit，cron，mail，usenet等，他们也都各自为相关的进程和文件所需要。</h6>
<p>由于<code>/etc/passwd</code>文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将其破解，因为安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存在一个文件中，这个文件是<code>/etc/shadow</code>文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<h6 id="2etcshadowetcpasswdpwconvetcpasswd">2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</h6>
<p>它的文件格式与<code>/etc/passwd</code>类似，由若干个字段组成，字段之间用<code>.</code>隔开。这些字段是：</p>
<pre><code>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标识
</code></pre><ul>
<li>&ldquo;登录名&quot;是与<code>/etc/passwd</code>文件中的登录名相一致的用户账号</li>
<li>&ldquo;口令&quot;字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合<code>{./0-9A-Za-z}</code>中的字符，则对应的用户不能登录。</li>
<li>&ldquo;最后一次修改时间&quot;表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如SCO Linux中，这个时间起点是1970年1月1日。</li>
<li>&ldquo;最小时间间隔&quot;指的是两次修改口令之间所需的最小天数。</li>
<li>&ldquo;警告时间&quot;字段表示的是从系统开始警告用户到用户密码正式失效时间的天数。</li>
<li>&ldquo;不活动时间&quot;表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>&ldquo;失效时间&quot;字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ul>
<p>下面是<code>/etc/shadow</code>的一个例子：</p>
<pre><code>root@ubantu:/# cat /etc/shadow
root:!:18306:0:99999:7:::
daemon:*:18113:0:99999:7:::
bin:*:18113:0:99999:7:::
sys:*:18113:0:99999:7:::
sync:*:18113:0:99999:7:::
games:*:18113:0:99999:7:::
man:*:18113:0:99999:7:::
lp:*:18113:0:99999:7:::
mail:*:18113:0:99999:7:::
....后面省略
</code></pre><h6 id="3etcgroup">3、用户组的所有信息都存放在/etc/group文件中。</h6>
<p>将用户分组是Linux系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在<code>/etc/passwd</code>文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组成为附加组。用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。用户组的所有信息都存放在<code>/etc/group</code>文件中。此文件的格式也类似于<code>/etc/passwd</code>文件，由冒号<code>:</code>隔开若干个字段，这些字段有：</p>
<pre><code>组名:口令:组标识号:组内用户列表
</code></pre><ul>
<li>&ldquo;组名&quot;是用户组的名称，由字母或数字构成。与<code>/etc/passwd</code>中的登录名一样，组名不应重复</li>
<li>&ldquo;口令&quot;字段存放的是用户组加密后的口令字。一般Linux系统的用户都没有口令，即这个字段一般为空，或者是*</li>
<li>&ldquo;组标识号&quot;与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>&ldquo;组内用户列表&quot;是属于这个组的所有用户的列表，不同用户之间用<code>,</code>分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ul>
<p><code>/ect/group</code>文件的一个例子如下：</p>
<pre><code>root@ubantu:/# cat /etc/group
root❌0:
daemon❌1:
bin❌2:
sys❌3:
adm❌4:syslog,leven
tty❌5:
disk❌6:
lp❌7:
mail❌8:
news❌9:
...后面省略
</code></pre><h4 id="heading-8">四、批量添加用户</h4>
<p>添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百甚至上千个用户时，我们不太可能还使用<code>use add</code>一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，方法如下：</p>
<h6 id="1-2">1、先编辑一个文本用户文件</h6>
<p>每一列按照<code>/etc/passwd</code>密码文件的格式书写，要注意每个用户名、UID、宿主目录都不可以相同，其中密码栏可以留作空白或输入x号。实例<code>user.txt</code>如下：</p>
<pre><code>user001::600:100:user:/home/user001:/bin/bash
user002::601:100:user:/home/user002:/bin/bash
user003::602:100:user:/home/user003:/bin/bash
user004::603:100:user:/home/user004:/bin/bash
user005::604:100:user:/home/user005:/bin/bash
user006::605:100:user:/home/user006:/bin/bash
</code></pre><h6 id="2rootusrsbinnewusersusertxt">2、以root身份执行命令<code>/usr/sbin/newusers</code>，从刚创建的用户文件<code>user.txt</code>中导入数据，创建用户:</h6>
<pre><code>root@ubantu:/# newusers &lt; user.txt 
</code></pre><p>然后可以执行命令 <code>vipw</code> 或 <code>vi /etc/passwd</code> 检查 <code>/etc/passwd</code> 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。</p>
<h6 id="3usrsbinpwunconv">3、执行命令<code>/usr/sbin/pwunconv</code></h6>
<p>将 <code>/etc/shadow</code> 产生的 <code>shadow</code> 密码解码，然后回写到 <code>/etc/passwd</code> 中，并将<code>/etc/shadow</code>的<code>shadow</code>密码栏删掉。这是为了方便下一步的密码转换工作，即先取消 <code>shadow password</code> 功能。</p>
<pre><code>root@ubantu:/# pwunconv
</code></pre><h6 id="4-3">4、编辑每个用户的密码对照表</h6>
<p>格式为：</p>
<pre><code>用户名:密码
</code></pre><p>实例文件<code>passwd.txt</code>内容如下：</p>
<pre><code>user001:123456
user002:123456
user003:123456
user004:123456
user005:123456
user006:123456
</code></pre><h6 id="5rootusrsbinchpasswd">5、以root身份执行命令<code>/usr/sbin/chpasswd</code></h6>
<p>创建用户密码，<code>chpasswd</code>会将经过<code>/usr/sbin/chpasswd</code>命令编码过的密码写入<code>/etc/passwd</code>的密码栏</p>
<pre><code>root@ubantu:/# chpasswd &lt; passwd.txt 
</code></pre><h6 id="6etcpasswd">6、确定密码经编码写入<code>/etc/passwd</code>的密码栏后</h6>
<p>执行命令<code>/usr/sbin/pwconv</code>将密码编码为<code>shadow password</code>，并将结果写入<code>/etc/shadow</code></p>
<pre><code>root@ubantu:/# pwconv 
</code></pre><p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p>
<h4 id="linux-4">五、Linux关机/重启</h4>
<p>shutdown指令</p>
<pre><code>sysnc				#将数据由内存同步到硬盘中。重启或关闭系统前，最好先执行一下此命令

shutdown			#关机指令，可以man shutdown来看一下帮助文档

shutdown -t 10 'This server will shutdown after 10 mins'		#这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登录用户的当前屏幕中

shutdown -h now 	#立马关机

shutdown -h 20:25	#系统会在今天20:25关机

shutdown -h +10 	#十分钟后关机

shutdown -r now 	#系统立马重启

shutdown -r +10 	#系统十分钟后重启

shutdown -p now     #关闭机器

shutdown -H now     #停止机器

shutdown -r09:35    #在09:35am重启机器

shutdown -c			#取消即将进行的关机操作
</code></pre><p>halt指令</p>
<pre><code>halt            	#停止机器/关闭系统，等同于shutdown -h now 和 poweroff

halt -p          	#关闭机器

halt --reboot   	#重启机器
</code></pre><p>poweroff指令</p>
<pre><code>poweroff            #关闭机器

poweroff --halt     #停止机器

poweroff --reboot   #重启机器
</code></pre><p>reboot指令</p>
<pre><code>reboot          	#重启，等同于shutdown -r now

reboot --halt   	#停止机器

reboot -p       	#关闭机器
</code></pre><h4 id="heading-9">六、补充实用指令</h4>
<h5 id="heading-10">重定向、追加指令</h5>
<pre><code>重定向：&gt; 文件名
如果文件内有内容则覆盖，如果文件不存在则先创建
eg：ls - l &gt; a.txt

追加： &gt;&gt; 文件名
如果文件内有内容会追加到内容的后面
eg:ls - l &gt;&gt; b.txt
</code></pre><h5 id="echo">echo指令</h5>
<pre><code>echo指令输出内容到控制台
echo [选项][输出内容]
eg:
root@ubantu:/home/leven# echo &quot;hello world!&quot;
hello world!
eg:
root@ubantu:/home/leven# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games


</code></pre><h5 id="linux-5">Linux链接概念</h5>
<p>Linux链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接 又叫软链接（Symbolic Link）。默认情况下，<code>ln</code>命令产生硬链接。</p>
<h6 id="heading-11">硬链接</h6>
<p>硬链接指通过索引节点来进行链接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号（Inode Index）。在Linux中，多个文件名指向同一个索引节点是存在的。比如：A是B的硬链接，则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>
<p>硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止误删的可能性。其原因如上所述，因为对应该目录的索引节点有一个以上的链接。只删除一个链接并不影响索引节点本身和其他的链接，只有当最后一个链接被删除后，文件的数据块及目录的链接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除。</p>
<h6 id="heading-12">软链接</h6>
<p>另外一种链接称之为符号链接（Symbolic Link），也叫软链接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号链接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A是B的软链接，A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是”主从“关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<h6 id="heading-13">通过实验加深理解</h6>
<pre><code>root@Kali:~# touch f1
root@Kali:~# ln f1 f2
root@Kali:~# ln -s f1 f3
root@Kali:~# ls -li

154067 -rw-r--r-- 2 root root    0 Feb  9 09:45 f1
154067 -rw-r--r-- 2 root root    0 Feb  9 09:45 f2
154075 lrwxrwxrwx 1 root root    2 Feb  9 09:46 f3 -&gt; f1
</code></pre><p>从上面的结果中可以看出，硬链接文件f2与原文件f1的inode节点相同，均为154067，然而软链接文件的inode节点不同。</p>
<pre><code>root@Kali:~# echo &quot;This is a link-test file&quot; &gt;&gt; f1
root@Kali:~# cat f1
This is a link-test file
root@Kali:~# cat f2
This is a link-test file
root@Kali:~# cat f3
This is a link-test file
root@Kali:~# rm -f f1
root@Kali:~# cat f2
This is a link-test file
root@Kali:~# cat f3
cat: f3: No such file or directory
</code></pre><p>通过上面的测试可以看出：当删除原始文件f1后，硬链接f2不受影响，但是软链接f3文件无效。</p>
<h5 id="history">history指令</h5>
<pre><code>查看已经执行过的历史命令，也可以执行历史指令
eg:
root@ubantu:/home/leven# history
    1  ./vmware-install.pl 
    2  tar -zvxf VMwareTools-10.3.10-13959562.tar.gz 
    3  cd /
    4  exit
    5  su - leven
    6  echo &quot;hello world!&quot;
    7  echo $path
    8  echo $PATH
    9  history
root@ubantu:/home/leven# 

eg:显示最近使用过的5个指令
root@ubantu:/home/leven# history 5
    6  echo &quot;hello world!&quot;
    7  echo $path
    8  echo $PATH
    9  history
   10  history 5

eg:执行历史编号为6的指令
root@ubantu:/home/leven# !6
echo &quot;hello world!&quot;
hello world!

</code></pre><h5 id="date">date指令</h5>
<ul>
<li>date：显示当前时间</li>
<li>date+%Y：显示当前年份</li>
<li>date+%m：显示当前月份</li>
<li>date+%d：显示当前哪一天</li>
<li>date &ldquo;+%Y-%m-%d %H:%M:%S&rdquo; ：显示年月日时分秒</li>
<li>date -s 字符串时间：设置成系统当前时间</li>
</ul>
<pre><code>eg:显示当前时间信息
root@ubantu:~# date
Sat Mar  7 23:35:32 CST 2020

eg:显示当前时间乃年月日
root@ubantu:~# date &quot;+%Y-%m-%d&quot;
2020-03-07

eg:显示当前时间年月日时分秒
root@ubantu:~# date &quot;+%Y-%m-%d %H:%M:%S&quot;
2020-03-07 23:39:31

eg:设置系统当前时间
root@ubantu:~# date -s &quot;2020-03-07 23:58:58&quot;
</code></pre><h5 id="cal">cal指令</h5>
<p>查看日历</p>
<pre><code>eg:查看当前日历
root@ubantu:~# cal
     March 2020       
Su Mo Tu We Th Fr Sa  
 1  2  3  4  5  6  7  
 8  9 10 11 12 13 14  
15 16 17 18 19 20 21  
22 23 24 25 26 27 28  
29 30 31              

eg:查看全年日历
root@ubantu:~# cal 2020
                            2020
      January               February               March          
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  
          1  2  3  4                     1   1  2  3  4  5  6  7  
 5  6  7  8  9 10 11   2  3  4  5  6  7  8   8  9 10 11 12 13 14  
12 13 14 15 16 17 18   9 10 11 12 13 14 15  15 16 17 18 19 20 21  
19 20 21 22 23 24 25  16 17 18 19 20 21 22  22 23 24 25 26 27 28  
26 27 28 29 30 31     23 24 25 26 27 28 29  29 30 31              
                                                                  

       April                  May                   June          
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  
          1  2  3  4                  1  2      1  2  3  4  5  6  
 5  6  7  8  9 10 11   3  4  5  6  7  8  9   7  8  9 10 11 12 13  
12 13 14 15 16 17 18  10 11 12 13 14 15 16  14 15 16 17 18 19 20  
19 20 21 22 23 24 25  17 18 19 20 21 22 23  21 22 23 24 25 26 27  
26 27 28 29 30        24 25 26 27 28 29 30  28 29 30              
                      31                                          

        July                 August              September        
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  
          1  2  3  4                     1         1  2  3  4  5  
 5  6  7  8  9 10 11   2  3  4  5  6  7  8   6  7  8  9 10 11 12  
12 13 14 15 16 17 18   9 10 11 12 13 14 15  13 14 15 16 17 18 19  
19 20 21 22 23 24 25  16 17 18 19 20 21 22  20 21 22 23 24 25 26  
26 27 28 29 30 31     23 24 25 26 27 28 29  27 28 29 30           
                      30 31                                       

      October               November              December        
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  
             1  2  3   1  2  3  4  5  6  7         1  2  3  4  5  
 4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12  
11 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19  
18 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26  
25 26 27 28 29 30 31  29 30                 27 28 29 30 31 
</code></pre><h5 id="find">find指令</h5>
<p>find指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或目录显示在终端</p>
<ul>
<li>
<p>find [搜索范围] [选项]</p>
</li>
<li>
<p>选项说明</p>
<pre><code>-name&lt;查询方式&gt;		按照指定的文件名查找模式查找文件
  
-user&lt;用户名&gt;		查找属于指定用户名所有文件
  
-size&lt;文件大小&gt;		按照指定的文件大小查找文件
</code></pre></li>
</ul>
<pre><code>eg:按文件名，根据名称查找/home目录下的hello.txt文件
root@ubantu:~# find /home -name hello.txt
/home/hello.txt
root@ubantu:~# 

eg:按拥有者，查找/opt目录下，用户名称为leven的文件
root@ubantu:~# find /opt -user leven

eg：查找整个linux系统下大于20M的文件(+n 大于  -n 小于  n 等于)
root@ubantu:~# find / size +20M

</code></pre><h5 id="locate">locate指令</h5>
<p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的精确度，管理员必须定期更新locate时刻。</p>
<ul>
<li>
<p>基本语法</p>
<p>locate 搜索文件</p>
</li>
<li>
<p>特别说明</p>
<p>由于locate指令基于数据库进行查询，所以第一次运行前，必须使用update指令创建locate数据库。</p>
</li>
</ul>
<pre><code>eg:请使用locate指令快速定位hello.txt文件所在目录
root@ubantu:~# updatedb
root@ubantu:~# locate hello.txt
/home/hello.txt
/usr/share/doc/syslinux-common/asciidoc/hello.txt
root@ubantu:~# 

</code></pre><h5 id="grep">grep、管道符指令</h5>
<p>grep过滤查找，管道符，&ldquo;|&rdquo;，表示将前一个命令的处理结果输出传递给后面的命令处理。</p>
<ul>
<li>
<p>基本语法</p>
<p>grep [选项]  查找内容  源文件</p>
</li>
<li>
<p>常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>显示匹配行及行号</td>
</tr>
<tr>
<td>-i</td>
<td>忽略字母大小写</td>
</tr>
</tbody>
</table>
</li>
</ul>
<pre><code>eg:请在hello.txt文件中，查找&quot;yes&quot;所在行，并且显示行号
root@ubantu:/home# cat hello.txt | grep -n yes
5:yes,I'm fine
root@ubantu:/home# 
root@ubantu:/home# cat hello.txt | grep -ni yes
6:yes
9:YES
root@ubantu:/home# 
</code></pre><h5 id="heading-14">压缩、解压类指令</h5>
<h6 id="gzipgunzip-">gzip/gunzip 指令</h6>
<p>gzip用于压缩文件，gunzip用于解压文件</p>
<ul>
<li>
<p>基本语法</p>
<p>gzip  文件  （职能将文件压缩为*.gz文件）</p>
<p>gunzip  文件.zip	（解压缩文件命令）</p>
</li>
</ul>
<pre><code>eg:gzip压缩，将/home下的hello.txt文件进行压缩
root@ubantu:/home# gzip hello.txt 
root@ubantu:/home# ls -l
total 32
-rw-r--r--  1 root    root    85 Mar  8 11:27 hello.txt.gz
drwxr-xr-x 17 leven   leven 4096 Mar  8 10:51 leven
drwxr-xr-x  2 user001 users 4096 Feb 22 15:39 user001
drwxr-xr-x  2 user002 users 4096 Feb 22 15:39 user002
drwxr-xr-x  2 user003 users 4096 Feb 22 15:39 user003
drwxr-xr-x  2 user004 users 4096 Feb 22 15:39 user004
drwxr-xr-x  2 user005 users 4096 Feb 22 15:39 user005
drwxr-xr-x  2 user006 users 4096 Feb 22 15:39 user006
root@ubantu:/home# 
##可以看出，gzip指令将原文件压缩成.gz文件后，原文件会被删除

root@ubantu:/home# gunzip hello.txt.gz 
root@ubantu:/home# ls -l
total 32
-rw-r--r--  1 root    root    57 Mar  8 11:27 hello.txt
drwxr-xr-x 17 leven   leven 4096 Mar  8 10:51 leven
drwxr-xr-x  2 user001 users 4096 Feb 22 15:39 user001
drwxr-xr-x  2 user002 users 4096 Feb 22 15:39 user002
drwxr-xr-x  2 user003 users 4096 Feb 22 15:39 user003
drwxr-xr-x  2 user004 users 4096 Feb 22 15:39 user004
drwxr-xr-x  2 user005 users 4096 Feb 22 15:39 user005
drwxr-xr-x  2 user006 users 4096 Feb 22 15:39 user006

</code></pre><h6 id="zipunzip">zip/unzip指令</h6>
<p>zip用于压缩文件，unzip用于解压的</p>
<ul>
<li>
<p>基本语法</p>
<p>zip  [选项]  xxx.zip  将要压缩的内容</p>
<p>unzip   [选项]  xxx.zip</p>
</li>
<li>
<p>zip常用选项
-r：递归压缩，即压缩目录</p>
</li>
<li>
<p>unzip的常用选项
-d &lt;目录&gt;：指定解压后文件的存放目录</p>
</li>
</ul>
<pre><code>eg：将/home下的所有文件进行压缩成mypackage.zip
root@ubantu:/home# zip -r mypackage.zip /home/
root@ubantu:/home# ls -l
total 120064
-rw-r--r--  1 root    root         57 Mar  8 11:27 hello.txt
drwxr-xr-x 17 leven   leven      4096 Mar  8 10:51 leven
-rw-r--r--  1 root    root  122910632 Mar  8 14:51 mypackage.zip
drwxr-xr-x  2 user001 users      4096 Feb 22 15:39 user001
drwxr-xr-x  2 user002 users      4096 Feb 22 15:39 user002
drwxr-xr-x  2 user003 users      4096 Feb 22 15:39 user003
drwxr-xr-x  2 user004 users      4096 Feb 22 15:39 user004
drwxr-xr-x  2 user005 users      4096 Feb 22 15:39 user005
drwxr-xr-x  2 user006 users      4096 Feb 22 15:39 user006

eg:将mypackage.zip解压到/opt/tmp目录下
root@ubantu:/home# unzip -d /opt/tmp mypackage.zip 

</code></pre><h6 id="tar">tar指令</h6>
<p>tar指令是打包指令，最后打包的文件是<code>.tar.gz</code>形式的文件。</p>
<ul>
<li>
<p>基本语法</p>
<p>tar  [选项]  xxx.tar.gz  打包的内容</p>
</li>
<li>
<p>选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>产生<code>.tar</code>打包文件</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细信息</td>
</tr>
<tr>
<td>-f</td>
<td>指定压缩后的文件名</td>
</tr>
<tr>
<td>-z</td>
<td>打包同时压缩</td>
</tr>
<tr>
<td>-x</td>
<td>解包<code>.tar</code>文件</td>
</tr>
</tbody>
</table>
<pre><code>eg:压缩多个文件，将/home/a1.txt和/home/a2.txt压缩成 a.tar.gz
root@ubantu:/home# tar -zcvf a.tar.gz a1.txt a2.txt 
a1.txt
a2.txt
root@ubantu:/home# ls -l
total 120068
-rw-r--r--  1 root    root          0 Mar  8 15:02 a1.txt
-rw-r--r--  1 root    root          0 Mar  8 15:02 a2.txt
-rw-r--r--  1 root    root        121 Mar  8 15:03 a.tar.gz
-rw-r--r--  1 root    root         57 Mar  8 11:27 hello.txt
drwxr-xr-x 17 leven   leven      4096 Mar  8 10:51 leven
-rw-r--r--  1 root    root  122910632 Mar  8 14:51 mypackage.zip
drwxr-xr-x  2 user001 users      4096 Feb 22 15:39 user001
drwxr-xr-x  2 user002 users      4096 Feb 22 15:39 user002
drwxr-xr-x  2 user003 users      4096 Feb 22 15:39 user003
drwxr-xr-x  2 user004 users      4096 Feb 22 15:39 user004
drwxr-xr-x  2 user005 users      4096 Feb 22 15:39 user005
drwxr-xr-x  2 user006 users      4096 Feb 22 15:39 user006
  
eg:将/home的文件夹压缩成myhome.tar.gz
root@ubantu:/home# tar -zcvf myhome.tar.gz /home/
  
eg:将a.tar.gz解压到当前目录
root@ubantu:/home# tar -zxvf a.tar.gz 
a1.txt
a2.txt
root@ubantu:/home# ls -l
total 120068
-rw-r--r--  1 root    root          0 Mar  8 15:02 a1.txt
-rw-r--r--  1 root    root          0 Mar  8 15:02 a2.txt
-rw-r--r--  1 root    root        121 Mar  8 15:03 a.tar.gz
-rw-r--r--  1 root    root         57 Mar  8 11:27 hello.txt
  
  
eg:将myhome.tar.gz解压到 /opt/tmp2目录下
root@ubantu:/home# tar -zxvf myhome.tar.gz /opt/tmp2
  
</code></pre></li>
</ul>
<h5 id="crond">crond任务调度</h5>
<p>概述
任务调度：是指系统在某个时间执行的特定命令或程序。
任务调度分类：1、系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等。2、个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库地备份。</p>
<p>**注：**如果只是简单的任务，可以不用写脚本，直接在crontab中加入任务即可；如果是比较负责的任务，则需要编写脚本。</p>
<p>基本语法
<code>crontab</code>  [选项]</p>
<p>常用选项</p>
<table>
<thead>
<tr>
<th>-e</th>
<th>编辑crontab定时任务</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>查询crontab任务</td>
</tr>
<tr>
<td>-r</td>
<td>删除当前用户所有的crontab任务</td>
</tr>
</tbody>
</table>
<pre><code>eg:
设置任务调度文件：/etc/crontab
设置个人任务调度。执行crontab -e命令
接着输入任务到调度文件
如：*/1 * * * * ls -l /etc/ &gt;&gt; /tmp/to.txt
意思是说每小时的每分钟执行ls -l /etc/ &gt;&gt; /tmp/to.txt 命令

root@ubantu:/# crontab -e
#进入后把 */1 * * * * ls -l /etc/ &gt;&gt; /tmp/to.txt 写进去，再保存退出
#则在每一分钟都会自动的调用上面的这条命令

</code></pre><p>参数细节说明：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一个&rdquo;*&rdquo;</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个&rdquo;*&rdquo;</td>
<td>一天当中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个&rdquo;*&rdquo;</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个&rdquo;*&rdquo;</td>
<td>一年当中的第几个月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个&rdquo;*&rdquo;</td>
<td>一周当中的星期几</td>
<td>0-7（0和7都代表星期日）</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>代表任何时间。比如第一个”*“就代表一小时中每分钟执行一次的意思。</td>
</tr>
<tr>
<td>,</td>
<td>代表不连续的时间。比如：”0 8,12,16 * * *  命令“，就代表在每天的8点0分，12点0分，16点0分都执行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间范围。比如”0 5 * * 1-6  命令“，就代表在周一到周六的凌晨5点0分执行命令</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次。比如&rdquo;*/10 * * * *  命令&rdquo;，代表每隔10分钟就执行一次命令</td>
</tr>
</tbody>
</table>
<p>特定时间执行任务案例</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>45 22 * * *  命令</td>
<td>在22点45分执行命令</td>
</tr>
<tr>
<td>0 17 * * 1  命令</td>
<td>每周一的17点0分执行命令</td>
</tr>
<tr>
<td>0 5 1,15 * *  命令</td>
<td>每月1号和15号的凌晨5点0分执行命令</td>
</tr>
<tr>
<td>40 4 * * 1-5  命令</td>
<td>每周一到周五的凌晨4点40分执行命令</td>
</tr>
<tr>
<td>*/10 4 * * *  命令</td>
<td>每天凌晨4点,每隔10分钟执行一次命令</td>
</tr>
<tr>
<td>0 0 1,15 * 1  命令</td>
<td>每月1号和15号，每周一的0点0分都会执行命令。<!-- raw HTML omitted -->注意：星期几和几号最好不要同时出现，因为他们定义的都是天。非常容易让管理员混乱</td>
</tr>
</tbody>
</table>
<pre><code>案例：在home目录下创建一个task1.sh,写进 date &gt;&gt; /tmp/mydate,crontab -e，写进 */1 * * * * /home/task1.sh ;然后每隔一分钟查看/tmp/mydate的内容
root@ubantu:/home# vi task1.sh
# date &gt;&gt; /tmp/mydate
root@ubantu:/home# crontab -e
# */1 * * * * /home/task1.sh
root@ubantu:/tmp# cat mydate 
Hello,Linux
Sun Mar  8 18:29:01 CST 2020
Sun Mar  8 18:30:01 CST 2020
Sun Mar  8 18:31:01 CST 2020
</code></pre><h6 id="crond-1">crond相关指令：</h6>
<ul>
<li>crontab -r：终止任务调度</li>
<li>crontab -l：列出当前有哪些任务调度</li>
<li>service crond restart ：重启任务调度</li>
</ul>

            </div>
        </article>

        <hr />

        <div class="post-info">
  			</div>

        

        

        <div class="post-comment">
          
          
  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'ohbh5fM3KAyeRWwKMOY8N9Um-gzGzoHsz',
        appKey: 'SpDbtJwWMANkTWYyMb5L5geh',
        notify: 'false', 
        verify: 'false', 
        avatar:'mm', 
        placeholder: '说点什么吧...',
        visitor: 'true'
    });
  </script>
  

 
        </div>
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2020</span>
            
                <span><a href="https://Sun-GoKu.github.io/">GoKu</a></span>
            
            
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
            <span> <a href="https://Sun-GoKu.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="17" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></span>
            <span>Powered by <a href="http://gohugo.io">Hugo</a></span>
            
        </div>
    
    </div>
    <div class="footer__inner">
        <div class="footer__content">
                
            <span id="busuanzi_container_site_pv" src="//at.alicdn.com/t/font_1597733_2zjwzrrq2bo.css">
                总阅读量  <span id="busuanzi_value_site_pv"></span>
            </span>
            &nbsp;
            <span id="busuanzi_container_site_uv">
                访问人数 <span id="busuanzi_value_site_uv"></span>
            </span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="https://Sun-GoKu.github.io/bundle.min.2d5469329143160ae2456a69c3c76dc2d0a3b212b46afe291a51bd68650ed6f8697e001dab54f1c272c77ce08092a8c55e5bb4314e0ee334aab4b927ec896638.js" integrity="sha512-LVRpMpFDFgriRWppw8dtwtCjshK0av4pGlG9aGUO1vhpfgAdq1TxwnLHfOCAkqjFXlu0MU4O4zSqtLkn7IlmOA=="></script>



    </body>
</html>
